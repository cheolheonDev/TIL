// 
// 프로그램에서 지금 에 해당하는 부분 그리고 나중에 해당하는 부분 사이의 관계가 바로 
// 비동기 프로그램의 핵심이다. 

// 자바스크립트 언어에서 비동기성 asynchrony이란 무엇인지 작동 원리는 무엇인지, 
// 깊이 있는 배경 지식부터 쌓아보자

// 지금 부터 나중까지 기다리는 가장 간단한(사실상 최적의 ) 방법은 콜백 함수 (callback function)이라는 장치를
// 이용하는 것이다. 

// 동기적인 AJAX요청도 있지만, 브라우져 UI를 얼어붙게 할 뿐 아니라. 사용자와의 상호작용이 완전히 마비될 수 있다. 

// 비동기 콘솔
// 콘솔 메소드는 그 작동방법이나 요건이 명세에 정해져 있지 않다. 
// 백그라운드에서 비동기적으로 처리해야 성능상 유리하다. 
// 간혹 브라우져가, 콘솔 IO를 백그라운드로 전환하는 것이 좋겠다고 결정하면,, 콘솔창에 예상대로 값이 안나올 수 있다. 


// 1.2 이벤트 루프 
// 자바스크립트에 비동기란 개념이 있었던 적은 한번도 없었다. 
// 엔진은 요청하면 주어진 시점에 한덩이씩 묵묵히 실행할 뿐이다. 

// 누가 요청을? 이 부분이 중요하다. 
// '이벤트'를 스케쥴링하는 일은 언제나 엔진을 감싸고 있던 주위 환경의 몫이었다. 

// 환경은 달라도 스레드 thread는 공통이다. 
// 여러 프로그램 덩이를 매 순간 한번씩 엔진을 실행시키는 이벤트 루프라는 장치다. (event loop)


// event loop 의사코드
/* 
var eventLoop = []; 
var event; 
while(true){
    //tick발생
    if(eventLoog.length>0){
        event = eventLoop.shift();
        try{
            event();
        }catch(err){
            reportError(err);
        }
    }
}
*/
// 틱이 발생할때마다 적재된 이벤트를 꺼내어 실행한다. 
// 
// setTimeout()타이머가 항상 완벽하게 정확한 타이밍으로 작동하지 않는 것이 이 이유, 
// 만약 이벤트 루프가 20개 원소로 가득차 있다면... 
// 적어도 얼마 시간 이전에 콜백이 실행되지 않을거라는 것은 보장할 수 있다. 


// 병렬스레딩
// 비동기와 병렬, 섞어 쓰는 경우가 많지만 완전히 다르다. 

// 이벤트 루프는 작업 단위로 나누어 차례대로 실행하지만 공유 메모리에 병렬로 접근하거나 변경할 수는 없다. 
// 병렬성( parallelism) , 직렬성( serialism)이 나뉜 스레드에서 이벤트 루프를 협동(cooperation)하는 형태로 공존하는 모습이다. 

// 병렬 실행 스레드 인터리빙(interleaving)과 비동기 이벤트 인터리빙은 완전히 다른 수준의 단위(granularity)에서 일어난다. 

// 단일 스레드로 작동하는 자바스크립트, 
// 비동기 이벤트의 실행결과 가 나오는 시간 차이에 따라 값이 달라질수는 있다. 
// 그러나 만약 두 스레드가 데이터를 공유하는 상태에서 병렬로 실행된다면
// 제멋대로 바뀌는 값에 따라 편두통에 걸릴것
//  threaded programming의 어려운점 ㅠㅠ
// 

// 자바스크립트는 level of nondeterminism은 문제가 되지 않는다. 
// 비결정성의 문제 .. 
// 그런데 그렇다고 derministic 항상 결정적이라는 얘기도 아니다. 

// 완전실행 
// 자바스크립트의 작동모드는 단일-스레드 이므로 foo() 내부의 코드는 원자적이다. (atomic)
// foo가 실행되면, 이 함수가 다 실행되어야 한다. 

/*
var a = 1;   // 1
var b = 2; 
function foo(){
    a++;       ///2
    b = b * a; 
    a = b + 3;
}
function bar(){
    b--;       ////3
    a = 8 + b; 
    b = a * 2; 
}
// ajax()는 임의의 ajax함수
ajax('http://some.url.1", foo)
ajax('http://some.url.2", bar)
*/

// foo, bar는 서로의 실행을 방해할 수 없다. 
// 2, 덩이와 3 덩이는 Either-First Order로 실행된다. 
// 결과는 둘중 하나이다. 

// 똑같은 코드인데 결과값은 두가지 이므로, 이 프로그램은 비 결정적이다. 
// 스레드보다는 결정적이라고 할 수 있다. 
// 함수 순서에 따른 비결정성을 흔히 경합조건이라고 표현한다 (race condition)


// 동시성 
// 스크롤바를 내리면 계속 갱신된 상태 리스트가 표시되는 웹 페이지를 만들고자 한다. 

// 2개의 분리된 프로세스가 동시에 실행할 수 있어야 제대로 기능을 구현할 수 있다. 
// 1. 사용자가 페이지의 스크롤바를 내리는 순간 발생하는 onscroll이벤트에 반응한다. 
// 2. ajax 응답을 받는다. 

// 아주 빨리 내린다면, 두 프로세스가 인터리빙된다. 
// 동시성은, 복수의 프로세스가 같은 시간동안 동시에 실행됨을 의미하며, 
// 각 프로세스 작업이 병렬로 처리되는지와는 관계없다. 
// 처리수준의 병행성과 상반되는 프로세스 수준의 병행성이라고 할 수 있다. 
// ( operation-level -> process-level )

//프로세스1과 프로세스2는 동시에 (작업수준의 병행성) 실행되지만, 
//이들을 구성하는 이벤트들은 이벤트 루프 큐에서 차례대로 실행된다. 

// 비상호작용
// 복수의 프로세스가 이벤트를 인터리빙할때 두 프로세스간에 연관된 작업이 없다면, 
// 상호작용은 사실 의미가 없다. 

// 상호작용
// 동시 프로세스들은 필요할 때 스코프나 돔을 통해 간접적으로 상호작용한다. 
// 경합조건이 잘 발생하지 않도록 잘 조율해주어야 한다. 

// 예) 
/*
    var res = []; 
    function response(data){
        if(data.url == "http://some.url.1"){
            res[0] = data;
        }
        else if(data.url == "http://some.url.2"){
            res[1] = data;
        }
    }
    ajax("...", response)
    ajax("...", response)
*/
// 어느 결과가 빨리오든 어느 슬롯에 데이터가 저장될지 확실해 진다. 

// 또는 Gate 관문을 만들 수 있다. 
/*
function foo(x){
    a = x * 2; 
    if(a && b){
        baz();
    }
}
function bar(y){
    b = y * 2; 
    if(a && b){
        baz();
    }
}
function baz(){
    console.log(a+b);
}
ajax('http://some.url.1", foo)
ajax('http://some.url.2", bar)
*/
// 반드시 둘 다 도착한 다음에 열린다. 

// Latch 걸쇠 ,, 선착순으로 해결할 수도 있다. 
// 달리기시합을 명시적으로 
/*
var a; 
function foo(x){
    if(!a) { 
        a = x * 2;
        baz(); 
    }
    if(!a) {
        a = x / 2; 
        baz();
    }
}
function baz { 
    console.log(a);
}
ajax('http://some.url.1", foo)
ajax('http://some.url.2", bar)
*/


// 협동 
// 실행시간이 오래걸리는 프로세스를 여러 단계/ 배치로 쪼개어 
// 각자 작업을 이벤트 루프 큐에 인터리빙 하도록 하는게 목표다. 

// 이벤트 루프 큐를 독점하지 않는 좀더 친화적이고 협동적인 동시 시스템이 되려면
// 각 결과를 비동기 배치로 처리하고 이벤트 루프에서 대기 중인 다른 이벤트와 함께 실행되게끔 해야 한다. 
/*

var res = []; 
function response(data){
    // 한번에 1000개씩 실행한다. 
    var chunk = data.splice(0,1000); 
    res = res.concat(
        chunk.map((val)=>val*2)
    );
    if(data.length > 0){
        // 다음 배치를 비동기 스케쥴링한다. 
        setTimeout(function(){
            response(data);
        },0)
    }
}
*/

//  setTimeout(..., 0) 은 비동기 스케쥴링 꼼수 중 하나로, 이 함수를 이벤트 루프 큐의 맨 뒤에 붙여주시오 라는 말이다 
//  연속 두번 set...을 호출해도 그 순서가 보장되리라는 보장은 없다. 
//  모든 환경에서 비동기 이벤트 순서를 고정할 직접적인 방법은 없다. 

// 잡 Job Queue
// es6부터 이벤트 루프 큐에 새롭게 도입된 개념이다. 
// 이밴트 루프 큐에서 매 틱의 끝자락에 매달려 있는 큐라고 생각하면 가장 알기 쉽다. 

// 비동기 특성이 내재된 액션으로 인해 전혀 새로운 이벤트가 이벤트 루프 큐에 추가되는 게 아니라 
// 현재 틱의 잡큐 끝 부분에 원소가 추가된다. 

// 롤러코스터를 타고 싶어 다시 대기열 맨끝에 서는게 이벤트 루프 큐라면
// 잡 큐는 내린 직후 바로 대기열 맨 앞에 .. 

console.log("a");
setTimeout(function() { 
    console.log("b");
}, 0)
schedule(function(){   //  잡 스케쥴링을 하는 API
    console.log("c");
    schedule(function(){
        console.log("d");
    })
})
//  답은 abcd가 아닌 a c d b 
//  잡은 가능하자면 현재 이벤트 루프 틱 내에서 실행하도록 
//  타이머는 다음 이벤트 루프 틱에서 실행하도록 스케쥴링

