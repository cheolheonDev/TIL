// 벤치마킹
// 단순 소요시간으로만 측정한다면 너무 낙관적이다. 

// 반복
// 왜곡을 확실히 상쇄하려면, 평균을 낼 샘플이 아주 많아야 한다. 

// benchmark.js
// 통계학적으로 검증된 벤치마킹 도구다 

// 콘텍스트가 제일
// 1초에 X, 10,000,000개  Y 8,000,000개를 실행했다면, 
// X가 더 빠르다고 하겠지만, 
// 우리가 인식할 범위를 벗어나므로 의미가 없다. 

// 엔진최적화
// 실제 코드가 아닌 테스팅 만으로 실제 결과를 알수는 없다. 

// jsPerf.com
// 접속가능한 공개 URL에 대하여 통계적으로 정확하고 믿음성 있는 테스트를 대행한다.

// 정상테스트
// 좋은 테스트를 작성하려면, 
// 두 테스트 케이스 사이의 차이점은 무엇인지, 그 차이점은
// 의도적인지, 비의도적인지를 철저하게 분석하고 고민해야 한다. 

// 정확한 테스트 의도가 무엇인지 미묘한 세부분까지 시간을 들여 문서화하라 

// 미시성능
// 실제로 엔진이 실행하는 코드가 자신이 작성한 코드와 같지 않을 수 있다는 사실을 당연하게 받아들여야 한다. 

// 재귀
// unrolling recursion이 일어날 수 있다. 
// 
// ++i i++ 미시성능차이에 집착하지 말자
// 또 다른 미시성능차이에 집착한 예 
var x = [];
for(var i = 0; i < x.length; i++ ) {
    console.log(i);
}
for(var i = 0, len= x.length ; i < len ; i++){
    console.log(i);
}
// len을 캐시하면 더빨라질 것이다. 
// v8같은 일부 엔진에서는 엔진이 자체 해결하는 것보다 성능이 떨어진다.



// 똑같은 엔진은 없다. 
// 특정 엔진에 맞춰 최적화 열심히 해봐도 결국은 달라질 수 있다. 

// 예).. 문자열 + 와 join 최적화

// 점유율이 높은 브라우져가 권장하더라도.. 
// 일단 개발자는 올바른 코드를 작성하고 나중에 .. 성능개선이 이루어지길 기대하는 편이 현실적이다. 
// 임시로 넣은 꼼수보다 더 영속적인 것은 없다. 

// 큰 그림
// 미묘한 미세성능에 사로잡히지 말고 최적화의 큰 그림을 볼 수 있어야 한다. 

// 도날드 커누스
// 너무 이른 최적화는 만병의 근원이다. 

// 도날드 커누스가 한 말을 전문 인용하자면 

// 개발자들은 자신이 짠 코드 중 비임계 경로의 실행 속도를 신경쓰고 걱정하느라 많은 시간을 
// 낭비하는 경향이 있는데 디버깅/유지보수 관점에서 이런 식으로 효율을 높여보고자 하는 행위는 매우 부정적인
// 영향을 끼친다. 97프로의 자잘한 효율은 잊어버려라 너무 이른 최적화는 만병의 근원이다. 
// 3프로 임계경로에 대한 최적화는 미루면 안된다. 

// 문자열 -> 숫자로 강제변환하는 경우 

var x = "42" 
var y = x / 2; 
var y = parseInt(x,0) / 2; 
var y = Number(x) / 2;
var y = +x / 2;
var y = (x | 0) / 2; 

// 꼬리 호출 최적화(TCO)
// 함수 호출부가 함수의 꼬리 부분에 있고 호출이 끝나면 더이상 수행할 작업을 남기지 않는 방식

function factorial(n){
    function fact(n, res){
        if ( n < 2) return res; 
        return fact(n-1 , n*res)
    }
    return fact(n,1);
}
factorial(5);
// 두 fact()호출이 꼬리 위치에 있으면 TCO로 최적화 할 수 있다. 
// es6로 이 구현 요건을 규정한 것은, 재귀 알고리즘을 안쓰려는 경향이 있기 때문(스택 한계를 노심초사한 나머지)




