// 자바스크립트에서 비동기성이 중요한 이유
// 성능! 

// 웹 워커 
// 자바스크립트는 단일 스레드로만 돌아간다. 
// 단일 스레드가 프로그램 실행을 구조화할 수 있는 유일한 방법은 아니다. 

// 자바스크립트 언어 자체와는 관계없는, 브라우져 특성
// 자바스크립트는 현재까지 스레드 실행을 지원하지 않는다. 

// 브라우저 같은 환경은 다수의 자바스크립트 엔진 인스턴스를 쉽게 내어줄 수 있고 인스턴스마다
// 개별 스레드를 배정하여 실행할 수도 있다

// 이러한 프로그램의 독립적인 스레드 조각을 워커라고 하는데 프로그램을 덩이로 나누어
// 병렬 실행하는 작업 병행성 (Task Parallelism) 을 추구한다. 

// 워커 인스턴스화 하기 
var w1 = new Worker("http://some.url.1/mycoolwokker.js");
// blob url로 인라인 워커를 생성하는 방법도 있다. 

// 워커는 같은 워커끼리 기본적인 이벤트 메시징 체계를 바탕으로 서로 연결한다. 
// 워커 객체에 이벤트를 구독하고 이벤트를 보내는 법
w1.addEventListener("메시지", function(evt){
    // evt.data
});
w1.postMessage("아주 재미난 이야기")

// 워커 내부 메시징 
// mycoolworker.js

addEventListener("메시지", function(evt){
    // evt.data
})
postMessage("..."); 

// 전용워커는 자신을 만든 프로그램과 1:1 관계라는 사실을 기억하자 
// 메시지 이벤트는 오직 이 1:1관계에서 비롯됬으니 굳이 구별할 이유가 없다. 

// 워커 환경, 
// 메인프로그램의 자원, 전역변수나 DOM등 여타 자원도 접근 불허다.
// 워커는 네트워크 작업(AJAX, 웹소켓)과 타이머 설정이 가능하며 
// navigator, location, JSON, applicationCache등 중요한 전역변수/특성을 자체 복사하여 접근할 수 있다. 

//
// 웹 워커의 주요 용도

// 처리 집약적 수학계산
// 대용량 데이터 세트 정렬
// 데이터 작업
// 트래픽 높은 네트워크 통신

// 
// 데이터 전송
// 대량의 데이터가 양방향 전송되어야 한다. 
// 문자열 값으로 직렬화 하는 방법뿐이었다. 

// 요즘에는 구조화된 복제 알고리즘으로 객체를 복사/복제한다. 
// 환형참조 객체도 복제할 수 있다. 
// 객체 문자열 변환 비용은 어쩔 수 없지만, 이 알고리즘을 쓰면 메모리에 사본을 둘 수 있다. 

// 데이터 세트 규모가 방대하면 트랜스퍼러블 객체를 고려하는 것이 좋다. 
// 객체는 그대로 두고 객체의 소유권만 전송하는 방식이다.  

// Unit8Array 같은 타입화 배열이 트랜스퍼러블의 예다. 
// 트랜스퍼러블 객체는 PostMessage()로 전송한다. 

// postMessage(foo.buffer, [foo.buffer])

// 공유 워커
// 포트 접속이 끊겨도 다른 포트 접속이 살아있으면, 공유워커는 지속되지만, 
// 전용워커는 자신을 초기화한 프로그램이 종료되면 자취를 감춘다. 

// 웹워커 폴리필은 부록에 


// SIMD 
// 데이터 비트를 병렬로 처리하기 

// asm.js
// 자바스크립트 언어에서 고도로 최적화 가능한 부분집합
// asm.js최적화
// 
// 엔진이 변수/연산 타입을 추론할 수 있게 해주는 몇가지 수법? 

var a = 42; 
var b = a | 0;
// 32비트 정수 타입이 되도록 강제 

(a + b) | 0;
// +가 32비트 정수의 연산이란 사실을 추론 가능

// asm.js 모듈
// 메모리 할당, 가비지 콜렉션, 스코프 접근 등 자바스크립트의 성능상의 문제의 해결 방안으로 제시된
// 더 정형화한 어떤 모듈
// 렉시컬 스코프를 통해 전역 객체를 쓰는대신, 엄격하게 규정된 네임스페이스를 분명하게 전달한다. 
//





