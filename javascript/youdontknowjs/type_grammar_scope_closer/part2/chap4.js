// 호이스팅

a = 2;
var a; 
console.log(a);

console.log(b);
var b = 2; 

// 둘다 undefined
// 선언문이 스코프에 어디에 있는지에 따라 스코프에 변수가 추가되는 과정에 미묘한 차이가 있다. 

// 컴파일러는 두 번 공격한다. 
// 인터프리팅 하기 전에 컴파일한다. 
// 컴파일레이션 단계 중에는 모든 선언문을 찾아 적적한 스코프에 연결해주는 과정이 있었다. 
// 이 과정이 렉시컬 스코프의 핵심!

// var a = 2;는 
// var a; 
// a = 2; 
// 이렇게 두개의 구문으로 나뉘어진다. 

//var a;  
//이 구문이 위 코드 블록 2개의 상단에 추가된다고 보면 된다. 
// 변수와 함수 선언문은 선언된 위치에서 코드의 꼭대기로 끌어올려 진다. 
// 이렇게 끌어올리는 동작을 'hoisting'이라고 한다. 

// 함수 표현식의 경우는.. 주의 
// 끌어올려지지 않는다. 
// typeError

// 함수 표현식이 이름을 가져도 그 이름 확인자는 해당 스코프에서 찾을 수 없다. 

//foo();  TypeError
//bar();  ReferenceError
var foo = function bar() {
};

// - 호이스팅을 적용하면 다음과 같이 해석된다. 
var foo; 
foo = function () {
    // var bar = self 
    // bar라는 이름은 내부에서만
}


// 함수가 먼저다 
// 함수 선언문이 변수보다 앞으로 가고 
// 중복 함수 선언문은 앞선 것들을 겹쳐쓴다. 

too(); /// 3
var too; 
function too(){
    console.log(1); 
}
too = function(){
    console.log(2);
}
function too(){
    console.log(3);
}


 // 중복 선언을 조심하자 
 // 일반 변수 선언과 함수 선언을 섞어 사용하면 특히 더 위험하다
