//scope 
// 특정 장소에 변수를 저장하고 나중에 그 변수를 찾는데 잘 정의된 규칙이 필요하다. 

// 자바스크립트 
// 컴파일러 언어다. 
// 
// compilation 
// 전통적인 컴파일러 언어의 처리 과정에서는 소스 코드가 실행되기 전에 세단계를 거친다. 

// tokenizing / lexing 
// tokenizer가 상태 유지 파싱 규칙을 적용해 a가 별개의 토큰인지 다른 토큰의 일부인 파악한다면 렉싱이다. 

// parsing 
// 토큰 배열을 프로그램의 문법 구조를 반영하여 중첩 원소를 갖는 트리형태로 바꾸는 과정이다. 
// 파싱의 결과로 만들어지는 트리를 AST(Abstract Syntax Tree) 추상 구문 트리 라고 부른다. 

// code generation
// 컴퓨터에서 실행 코드로 바꾸는 과정 
// ast를 기계어 집합으로 바꾸어 실제로 'a'라는 변수를 생성하고 값을 저장할 방법이 있다. 


// 컴파일레이션은 보통 코드가 실행되기 전 겨우 수백만 분의 일초 전에 수행한다. 
// 어떤 자바스크립트 조각이라도 실행되려면 먼저 컴파일 되어야 한다는 것이다. 


// 스코프 이해하기 
// 스코프의 진행? 
// 첫째 컴파일러가 변수를 선언한다. 
// 둘째 엔진이 스코프에서 변수를 찾고 변수가 있다면 값을 대입한다. 

// 컴파일러체
// 컴파일러가 변수를 검색할때 사용하는 종류 
// LHS left hand side 
// - 왼쪽방향 검색, 값을 넣어야 하므로 변수컨테이너 자체를 찾는다. 
a = 2; 
// RHS right hand side
// - 오른쪽 방향 검색, 단순히 특정 변수의 값을 찾는다
console.log(a);


function foo(a){  // 함수 선언문은 LHS검색 및 대입과정으로 생각하면 안된다. 
    console.log(a); // a를 찾는 RHS  // console.log 내부 로직에도 arg1에 a를 대입하는 LHS가 있을 것
}
foo(2);  // foo를 찾는 RHS, a=2 의 LHS

// 중첩 스코프 
// 스코프는 다른 스코프 안에 중첩될 수 있다. 
// 현재 스코프에서 변수를 찾기 시작하고 찾지 못하면 한단계씩 올라간다. 
// 최상위 스코프에 도달하면 변수를 찾았든 못찾았든 검색을 멈춘다. 

// 오류 
// LHS와 RHS를 구분하는 것이 중요한 이유는 변수가 아직 선언되지 않았을 때 서로 다르게 동작하기 때문
// 
// RHS 검색이 실패하면 다시는 b를 찾을 수 없다. 
// 중첩스코프안 어디서도 찾지 못하는 경우 referenceError를 발생시킨다. 

// LHS 검색이 실패할 경우 그래서 최상층 스코프에 도달하고, strict mode 로 실행되고 있는 것이 아니라면
// 글로벌 스코프는 해당 이름을 가진 새로운 글로벌 변수를 선언해서 엔진에게 넘겨준다. 
// strict mode 라면 referenceError를 던진다. 

// 결과값을 가지고 불가능한 시도를 할 경우 ( 예를 들어 함수가 아닌 값을 가지고 함수 호출을 한다면)
// TypeError를 발생시킨다

var a = 2; 

// 1. 변수 a를 해당 스코프에 선언한다 이 단계는 코드 실행 전에 처음부터 수행된다. 
// 2. a = 2 는 변수 a를 찾아 값에 대입한다. 